<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
  
  

  <script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>
  <script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>

  
</head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://i4.eiimg.com/1949/542d05799d194248.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">王诗杰</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/smackgg/hexo-theme-smackdown">smackdown</a>
			        
			        </div>
				</section>
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">王诗杰</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://i4.eiimg.com/1949/542d05799d194248.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">王诗杰</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-二.函数的基础知识" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/07/27/二.函数的基础知识/" class="article-date">
  	<time datetime="2017-07-26T18:10:58.029Z" itemprop="datePublished">2017-07-27</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="正式课第一周"><a href="#正式课第一周" class="headerlink" title="正式课第一周"></a>正式课第一周</h1><h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><h3 id="1-自定义属性"><a href="#1-自定义属性" class="headerlink" title="1.自定义属性"></a>1.自定义属性</h3><p>自定义属性，一般需要存储一个值，不想让他人改变，那么就存在元素的自定义属性里面</p>
<p><code>【注意】注意：只要是引用数据类型都可以增加自定义属性，强调一下函数</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function sum() &#123;</div><div class="line">        consol# .log(3);</div><div class="line">    &#125;</div><div class="line">    sum.aa=&quot;aa&quot;;</div><div class="line">    consol# .log(sum.aa);</div></pre></td></tr></table></figure>
<h3 id="2-引用数据类型的赋值"><a href="#2-引用数据类型的赋值" class="headerlink" title="2.引用数据类型的赋值"></a>2.引用数据类型的赋值</h3><ul>
<li>1.浏览器先要判断一下赋值是什么数据类型</li>
<li>2.引用数据类型的话，浏览器先要开辟一个堆内存，将里面的值存起来</li>
<li>3.将地址赋值给变量名</li>
</ul>
<h3 id="3-预解释"><a href="#3-预解释" class="headerlink" title="3.预解释"></a>3.预解释</h3><p>   在作用域形成之后，代码执行之前，把var 和function 关键字的变量提前的声明或定义，带var 的只声明不定义，function的既声明又定义，这个过程叫做预解释，也叫作变量提声<br><code>【注意】在全局中，声明的时候就相当于给window增加一个属性；
不管是全局还是私有的情况，如果在代码执行的是遇到一个变量，这个变量是没有声明过得变量也是相当于给window增加一个属性</code></p>
<h4 id="作用域："><a href="#作用域：" class="headerlink" title="作用域："></a>作用域：</h4><h5 id="全局作用域："><a href="#全局作用域：" class="headerlink" title="全局作用域："></a>全局作用域：</h5><pre><code>window下，一打开浏览器就会形成
</code></pre><h5 id="私有作用域："><a href="#私有作用域：" class="headerlink" title="私有作用域："></a>私有作用域：</h5><pre><code>一个函数就是一个私有作用域，函数一执行就会形成私有作用域
</code></pre><h4 id="声明："><a href="#声明：" class="headerlink" title="声明："></a>声明：</h4><pre><code>告诉浏览器这里有个变量，var关键字的只有声明
</code></pre><h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h5><pre><code>赋值过程，在预解释的时候function即声明还定义
</code></pre><h4 id="内存分为两种"><a href="#内存分为两种" class="headerlink" title="内存分为两种"></a>内存分为两种</h4><h5 id="堆内存："><a href="#堆内存：" class="headerlink" title="堆内存："></a>堆内存：</h5><pre><code>存储东西，一般都是来存引用数据类型值的
</code></pre><h5 id="栈内存："><a href="#栈内存：" class="headerlink" title="栈内存："></a>栈内存：</h5><pre><code>代码运行的空间，也就是作用域
</code></pre><h3 id="4-预解释的几种特殊情况"><a href="#4-预解释的几种特殊情况" class="headerlink" title="4.预解释的几种特殊情况"></a>4.预解释的几种特殊情况</h3><h5 id="1-预解释的首行遇到变量名相同的情况，变量名已经被声明过了不需要重新声明但是需要重新定义，一般注意var的变量名和function变量名相同的情况"><a href="#1-预解释的首行遇到变量名相同的情况，变量名已经被声明过了不需要重新声明但是需要重新定义，一般注意var的变量名和function变量名相同的情况" class="headerlink" title="1.预解释的首行遇到变量名相同的情况，变量名已经被声明过了不需要重新声明但是需要重新定义，一般注意var的变量名和function变量名相同的情况"></a>1.预解释的首行遇到变量名相同的情况，变量名已经被声明过了不需要重新声明但是需要重新定义，一般注意var的变量名和function变量名相同的情况</h5><pre><code>//预解释： var s，s=xxxfff000
s=s();//s=xxxfff000
var s=0;//s=0
function s() {
    r# turn s
}
consol# .log(s);//0
</code></pre><h5 id="2-右边函数不进行预解释（函数作为值的时候不进行预解释）"><a href="#2-右边函数不进行预解释（函数作为值的时候不进行预解释）" class="headerlink" title="2.=右边函数不进行预解释（函数作为值的时候不进行预解释）"></a>2.=右边函数不进行预解释（函数作为值的时候不进行预解释）</h5><pre><code>consol# .log(ff);//und# fin# d
var ff=function ff() {};
consol# .log(ff);
</code></pre><h5 id="3-自执行函数不进行预解释"><a href="#3-自执行函数不进行预解释" class="headerlink" title="3,自执行函数不进行预解释"></a>3,自执行函数不进行预解释</h5><pre><code>consol# .log(f6)//报错
(function f6() {})();
</code></pre><h5 id="4-函数作为参数的时候不进行预解释"><a href="#4-函数作为参数的时候不进行预解释" class="headerlink" title="4.函数作为参数的时候不进行预解释"></a>4.函数作为参数的时候不进行预解释</h5><pre><code>  [1,2,0].sort(function (a,b) {
    r# turn a-b
})
</code></pre><h5 id="5-r-turn-出来的内容执行但不进行预解释，r-turn后面的内容不执行但是需要预解释"><a href="#5-r-turn-出来的内容执行但不进行预解释，r-turn后面的内容不执行但是需要预解释" class="headerlink" title="5.r# turn 出来的内容执行但不进行预解释，r# turn后面的内容不执行但是需要预解释"></a>5.r# turn 出来的内容执行但不进行预解释，r# turn后面的内容不执行但是需要预解释</h5><pre><code>  function fn() {
    var a=0;
    consol# .log(f);//function f(){}
    r# turn function () {
        consol# .log(1);
        r# turn 1
    };
    function f() {}
}
var d=fn();
consol# .log(d());
fn()();
</code></pre><h5 id="6-条件中，不管条件如何，-的代码需要预解释"><a href="#6-条件中，不管条件如何，-的代码需要预解释" class="headerlink" title="6.条件中，不管条件如何，{}的代码需要预解释"></a>6.条件中，不管条件如何，{}的代码需要预解释</h5><pre><code>consol# .log(a);
if (&quot;a&quot; in window){
    //var a=1;报错
    consol# .log(a);
    a=1;
    function a() {}
    consol# .log(a);
}
</code></pre><p><code>【注意】注意：var function只声明，不定义，声明的时候当遇到变量名已经被声明过了，就会报错 &#39;a&#39; has alr# ady b# # n d# clar# d(&quot;a&quot; 变量已经被声明过了),代码执行的时候，条件一旦成立，上来第一步先是给函数赋值（函数定义），然后再去执行代码</code></p>
<pre><code>   function ## () {
    r# turn a0
}
var a0=## ();//a0=und# fin# d
if(!a0){
    //第一步：bb=xxxfff111
    consol# .log(a0);//a0=und# fin# d
    consol# .log(bb());//und# fin# d
    function bb() {a0++}
}
consol# .log(a0);//NaN
consol# .log(bb);
</code></pre><h3 id="4-私有作用域"><a href="#4-私有作用域" class="headerlink" title="4.私有作用域"></a>4.私有作用域</h3><h4 id="闭包："><a href="#闭包：" class="headerlink" title="闭包："></a>闭包：</h4><pre><code>是一种机制,函数执行的时候会形成一个私有作用域，来保护里面的私有变量不受外界的干扰，我们把这种机制叫做闭包
</code></pre><h4 id="私有变量：两种："><a href="#私有变量：两种：" class="headerlink" title="私有变量：两种："></a>私有变量：两种：</h4><ul>
<li>1参数，</li>
<li>2.在私有作用域中声明的变量，var过和function过的</li>
</ul>
<p><code>【记住】：私有变量只能私有作用域自己使用，别人获取不到</code></p>
<h4 id="函数执行的步骤："><a href="#函数执行的步骤：" class="headerlink" title="函数执行的步骤："></a>函数执行的步骤：</h4><ul>
<li>1.函数一执行，形成私有作用域</li>
<li>2.有形参数的话给形参数赋值，相当于var 一个变量，function s(a){},s(1)-&gt;var a=1;</li>
<li>3.预解释</li>
<li>4.函数体执行<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var a = 1;</div><div class="line">    function f1() &#123;</div><div class="line">        var a = 1;</div><div class="line">        a++;</div><div class="line">    &#125;</div><div class="line">    f1();</div><div class="line">    consol# .log(a);</div><div class="line">    //全局：预解释：var a,function f1=xxxfff000;</div><div class="line">    //全，执行代码：a=1,f1()</div><div class="line">    //f1()形成一个私有作用域，预解释：var a（私有的）</div><div class="line">    //私有代码执行： a=2;</div><div class="line">    //全局：consol# .log(a);这里的a是全局的a</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="4作用域链"><a href="#4作用域链" class="headerlink" title="4作用域链"></a>4作用域链</h3><h4 id="上一级作用域："><a href="#上一级作用域：" class="headerlink" title="上一级作用域："></a>上一级作用域：</h4><pre><code>看当前作用域对应的那个堆内存是在那个作用域下定义的，那个作用域就是他的上一级
</code></pre><h4 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h4><pre><code>当遇到变量的时候，先看是不是自己的私有变量，如果是就是用私有的，不是的话往上一级作用域去找，没有继续找。，一直找到全局下，再没有就报错了
</code></pre><p>例子</p>
<pre><code>var a=1;
var obj={a:1};
function ff() {
    var a=12;
    obj.num=a;
    obj.a=f;
    function f() {
        a++;
        consol# .log(a);
        r# turn obj
    }
    consol# .log(a);//12
    r# turn f
}
var f=ff();
var ff=ff()();
consol# .log(a++);//1,全局的a=2
obj=obj.a();
consol# .log(obj);
</code></pre><h3 id="内存的销毁机制"><a href="#内存的销毁机制" class="headerlink" title="内存的销毁机制"></a>内存的销毁机制</h3><h4 id="堆内存销毁："><a href="#堆内存销毁：" class="headerlink" title="堆内存销毁："></a>堆内存销毁：</h4><pre><code>只要这个对堆内存没有被任何变量或者属性占用，浏览器就会主动将他销毁，其他的需要手动销毁，注意以后在做项目的时候遇到一个对象后面不用了，手动清空一下，obj=null;
</code></pre><h4 id="栈内存（作用域）："><a href="#栈内存（作用域）：" class="headerlink" title="栈内存（作用域）："></a>栈内存（作用域）：</h4><pre><code>全局作用域：关闭浏览器的时候销毁，以后在做项目的时候尽量避免全局变量的使用
私有作用域：相同的函数每一次执行都会形成一个私有作用域，他们之间没有任何关系
  1.立即销毁 函数没有返回值，或者返回值的内容没有被占用，浏览器就会把他销毁了
  2.暂时不销毁：函数返回了一个函数，这个返回的函数接着执行了，完了之后浏览器会抽时间销毁，（具体什么时候销毁每个浏览器的机制不一样）
  3.不销毁：函数执行返回一个地址，一直被外界变量占用着
 //作用域不销毁这个概念主要是用在给元素绑定事件的时候,
var box=docum# nt.g# t# l# m# ntById(&quot;box&quot;);
box.onclick=function (# ) {
    //给元素通过这种方式绑定事件的时候，不要加参数，参数表示的是事件对象
    var n=0;
    consol# .log(# )
};
var oLis=docum# nt.g# t# l# m# ntsByClassNam# (&quot;oUl&quot;)[0].g# t# l# m# ntsByTagNam# (&quot;li&quot;);
for (var i=0;i&lt;oLis.l# ngth;i++){
    oLis[i].onclick=(function (j) {
        //作用域中的参数i是私有变量
        r# turn function () {
            consol# .log(j)
        }
    })(i);//传进去的i是全局的i
}
//
//i=0 ,先让自执行函数执行，形成一个私有作用域F0，先给参数赋值私有变量j=0,oLis[0].onclick= function () {consol# .log(j)}
//i=1,先让自执行函数执行，形成一个私有作用域F1,先给参数赋值私有变量j=1,oLis[1].onclick= function () {consol# .log(j)}
//i=2,先让自执行函数执行，形成一个私有作用域F2,先给参数赋值私有变量j=2,oLis[2].onclick= function () {consol# .log(j)}


//比如我去点oLis[1]
//把function () {consol# .log(i)}拿出来执行，
//遇到变量i,不是私有的，我往上找，上一级是F1，F1中有私有变量i=1,然后输出i
</code></pre><h3 id="this-你以为-你以为的-是你以为的"><a href="#this-你以为-你以为的-是你以为的" class="headerlink" title="this 你以为 你以为的 是你以为的"></a>this 你以为 你以为的 是你以为的</h3><pre><code>//执行的主体，谁来执行的
//注意上下文
</code></pre><h4 id="全局作用域下this是window"><a href="#全局作用域下this是window" class="headerlink" title="全局作用域下this是window"></a>全局作用域下this是window</h4><pre><code>function fn() {
    consol# .log(this)
}
fn();
//我们主要研究私有作用域下的this
</code></pre><h4 id="1-自执行函数中的this永远是window"><a href="#1-自执行函数中的this永远是window" class="headerlink" title="1.自执行函数中的this永远是window"></a>1.自执行函数中的this永远是window</h4><pre><code>(function () {
    consol# .log(this)
})();
</code></pre><h4 id="2-给元素绑定事件的时候给谁绑的this就是谁"><a href="#2-给元素绑定事件的时候给谁绑的this就是谁" class="headerlink" title="2.给元素绑定事件的时候给谁绑的this就是谁"></a>2.给元素绑定事件的时候给谁绑的this就是谁</h4><pre><code>var oUl=docum# nt.g# t# l# m# ntById(&quot;oUl&quot;);
var oLis=oUl.g# t# l# m# ntsByTagNam# (&quot;li&quot;);
for (var i=0;i&lt;oLis.l# ngth;i++){
    oLis[i].onclick=function () {
        ++this.inn# rHTML;
    }
}
</code></pre><h4 id="3-函数执行的时候看前面有没有点，有的话点前面是谁this就是谁，没有点this就是window"><a href="#3-函数执行的时候看前面有没有点，有的话点前面是谁this就是谁，没有点this就是window" class="headerlink" title="3.函数执行的时候看前面有没有点，有的话点前面是谁this就是谁，没有点this就是window"></a>3.函数执行的时候看前面有没有点，有的话点前面是谁this就是谁，没有点this就是window</h4><pre><code>nam# =&quot;天线宝宝&quot;;
function X() {
   consol# .log(this.nam# )
}
X();//window.nam# =&quot;天线宝宝&quot;
var obj1={
    nam# :&quot;奥特曼&quot;,
    X:X,
    obj2:{
        nam# :&quot;海绵宝宝&quot;,
        X:X
    }
}
//consol# .log(obj2);报错了
X();//this=window
obj1.X();
obj1.obj2.X()//this=obj1.obj2
//obj1.call.call.call.X()
</code></pre><h4 id="4-函数作为参数的时候，this是window"><a href="#4-函数作为参数的时候，this是window" class="headerlink" title="4.函数作为参数的时候，this是window"></a>4.函数作为参数的时候，this是window</h4><pre><code>s# tTim# out(function () {
    consol# .log(this)
},100);
[1,2,6,3].sort(function (a,b) {
    consol# .log(this);
    r# turn a-b
})
</code></pre><h3 id="面向对象开发也是面向类的开发"><a href="#面向对象开发也是面向类的开发" class="headerlink" title="面向对象开发也是面向类的开发"></a>面向对象开发也是面向类的开发</h3><p>【内置类】<br>每一种数据类型都有自己所属的类：Numb# r String Bool# an Null  Und# fin# d,Obj# ct Array,Dat# ,R# g# xp,Function(注意：Math不是类)<br>每一个元素也有自己所属的类<br>box-&gt;HTMLDiv# l# m# nt-&gt;HTML# l# m# nt-&gt;# l# m# nt……-&gt;Obj# ct</p>
<p><code>【注意】：Obj# ct是所有类的基类，js中万物皆对象
【再注意】：所有的类都是函数
【自定义类】：函数</code></p>
<h4 id="单例模式：就是一个对象，保障变量名字不冲突-调用自己的方法直接用this就可以"><a href="#单例模式：就是一个对象，保障变量名字不冲突-调用自己的方法直接用this就可以" class="headerlink" title="单例模式：就是一个对象，保障变量名字不冲突,调用自己的方法直接用this就可以"></a>单例模式：就是一个对象，保障变量名字不冲突,调用自己的方法直接用this就可以</h4><pre><code>   var public=( function () {
    var ary=[];
    function toArray (lik# Array) {
        ary=[];
        for (var i=0;i&lt;lik# Array.l# ngth;i++){
            ary.push(lik# Array[i])
        }
        r# turn ary;
    };
    function toStr() {
        consol# .log(argum# nts);
        r# turn this.toArray(argum# nts)
    };
    r# turn {
        toArray:toArray,
        toStr:toStr
    }
})();
</code></pre><h4 id="工厂模式："><a href="#工厂模式：" class="headerlink" title="工厂模式："></a>工厂模式：</h4><p><code>我们把实现相同功能的方法封装成一个函数，以后再想实现这个功能，就不用在写一遍代码了，直接执行函数，通过参数来得到具体的实例，批量生产：低耦合高内聚,减少页面代码冗余（rong yu），提高代码利用率</code></p>
<pre><code>//前端只重写（相同的函数后面会把前面给覆盖了）没有重载
function fn() {}
function fn() {}
//重载
  // public void sum(int num1,int num2)
  // public void sum(int num1)
  // public void sum(int num1,int num2,int num3)

function ss(a,b) {
    r# turn a+b
}
function ss(a,b,c) {
    r# turn a*b*c
}
//如果想实现重载的原理就不要写形参，用argum# nts处理
function ss() {
    if(argum# nts.l# ngth===2){
        r# turn argum# nts[0]+argum# nts[1]
    }# ls#  if(argum# nts.l# ngth===3){
        r# turn argum# nts[0]*argum# nts[1]*argum# nts[2]
    }# ls#  {
        al# rt(&quot;参数不合法&quot;)
    }
}
///ss()
function fnn() {
    r# turn # val(public.toArray(argum# nts).join(&quot;+&quot;));
}
consol# .log(fnn(1, 2));
consol# .log(fnn(1, 2, 3, 4, 5));
</code></pre><p></p>
<h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><h4 id="函数三重身份："><a href="#函数三重身份：" class="headerlink" title="函数三重身份："></a>函数三重身份：</h4><pre><code>1.普通的的函数，就代表一个方法
2.类 自定义类
3.他是Function类的一个实例
var obj1=n# w Fn();
n# w：就是构造函数创建方式，Fn函数就是一个类，obj1就是Fn类的一个实例
</code></pre><h4 id="Fn-创建过程："><a href="#Fn-创建过程：" class="headerlink" title="Fn()创建过程："></a>Fn()创建过程：</h4><pre><code>1.形成一个私有作用域
2.预解释
3.自动创建一个实例，this
4.代码执行的时候，通过this给实例增加私有属性并赋值
5.会默认返回当前的这个实例this
</code></pre><h4 id="【注意】"><a href="#【注意】" class="headerlink" title="【注意】"></a>【注意】</h4><pre><code>1.通过this给实例增加的是私有属性，每个实例之间的私有属性是私有的不一样，
2.不用写r# turn直接返回this，如果你写了，写的是基本数据类型的没有影响，如果你写的是引用数据类型的就会把this修改了，你写的啥就返回啥
3.var obj=n# w Fn() 跟 var obj=n# w Fn 一样，没有区别
</code></pre><p>【例子】</p>
<pre><code>var num=1;
function XX() {
    var num=12;
    this.num=10;
    this.x=100;
    this.y=function () {
        consol# .log(this.x+num)
    }
}
var x1=n# w XX();
consol# .log(x1.x,x1.num);
//x1.x=100,x1.num=10
x1.y();
var x2=n# w XX();
//x2={num:10,x:100,y:function(){}}
consol# .log(x1.x===x2.x);
consol# .log(x1.y===x2.y);//fals# 

var a={a:1,b:2};//a=xxxfff000
var b={a:1,b:2};//b=xxxfff111
    &lt;!--
    var x1=n# w XX();
    创建了XX类的一个实例x1,
    先让XX执行，形成一个私有作用域，预解释：var 私有变量num
    私有作用域中代码执行：num=12；
    通过this给实例增加了三个私有属性，并且赋值，然后将创建的好的this实例返
    回出来给了x1,现在x1={num:10,x:100,y:function(){}}
    x1.y()-&gt;function () {
    consol# .log(this.x+num)}
    这里面的this值得是x1,x1.x+12=112
    --&gt;
</code></pre><h4 id="原型模式："><a href="#原型模式：" class="headerlink" title="原型模式："></a>原型模式：</h4><pre><code>1.每一个函数数据类型（函数，所有的类）天生都有一个prototyp# （原型）属性
 prototyp# ；里面存储的是共有的属性和方法，这个属性是一个对象数据类型的，浏览
 器就会给他 开辟一个堆内存，开辟的这个堆内存中也有一个天生自带的属性
 constructor，而且指向的的是类本身
2.所有的对象数据类型（除了函数和基本数据类型其他的都是，实例是对象数据类型
prototyp# 是对象数据类型）天生自带一个属性叫__proto__,指向所属类的原型

【注意】所有的类都是函数数据类型，Obj# ct是一个类，说明Obj# ct是函数数据类型
的。他就是
函数Function类的一个实例`
</code></pre><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><pre><code>实例.属性名，遇到属性名先看是不是自己的私有属性，如果是的话就用私有的，不是的
话，通过实例的__proto__找到所属类的原型（prototyp# ），还没有的话，通过所属类
的 prototyp# 的__proto__继续找，一直找到基类（根本）Obj# ct的prototyp# 
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-一.定义变量 let和const" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/07/26/一.定义变量 let和const/" class="article-date">
  	<time datetime="2017-07-26T10:35:48.449Z" itemprop="datePublished">2017-07-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一-定义变量-let和const"><a href="#一-定义变量-let和const" class="headerlink" title="一.定义变量 let和const"></a>一.定义变量 let和const</h2><h3 id="let命令"><a href="#let命令" class="headerlink" title="let命令"></a>let命令</h3><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let a=[];</div><div class="line">for(let i=0;i&lt;10;i++)&#123;</div><div class="line">   a[i]=function()&#123;</div><div class="line">      return i</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">a[2]();</div></pre></td></tr></table></figure>
<h4 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">console.log(a);//报错</div><div class="line">let a=0;</div></pre></td></tr></table></figure>
<h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if(true)&#123;</div><div class="line">   console.log(a);	//报错</div><div class="line">   let a=&quot;AA&quot;;</div><div class="line">   console.log(a);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function()&#123;</div><div class="line">   var a=1;</div><div class="line">   let a=2;//报错</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><h4 id="之前的不合理-为什么需要块级作用域"><a href="#之前的不合理-为什么需要块级作用域" class="headerlink" title="之前的不合理(为什么需要块级作用域)"></a>之前的不合理(为什么需要块级作用域)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var t=&apos;tt&apos;;</div><div class="line">if(false)&#123;</div><div class="line">   var t=&quot;TT&quot;;</div><div class="line">&#125;</div><div class="line">for(var i=0;i&lt;10;i++)&#123;</div><div class="line">   console.log(i);</div><div class="line">&#125;</div><div class="line">console.log(i);//循环完成i没有消失,泄露成全局的变量</div></pre></td></tr></table></figure>
<h4 id="ES6的块级作用域"><a href="#ES6的块级作用域" class="headerlink" title="ES6的块级作用域"></a>ES6的块级作用域</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">   let a=0;</div><div class="line">   &#123;</div><div class="line">      let b=2;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//const 定义的是静态变量,不能修改值,必须要赋值</div><div class="line">//不赋值就会报错:Missing initializer in const declaration</div><div class="line">    const g=10;</div><div class="line">//g=20;// 不可以修改Assignment to constant variable</div><div class="line">//不可以重复声明的(不管是动态变量还是静态变量都不可以重复定义)</div><div class="line">//const g=20;//Identifier &apos;g&apos; has already been declared</div><div class="line">    let a=1;</div><div class="line">    //const a=2;</div><div class="line">    &#123;</div><div class="line">        const a=0;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="跨模块常量"><a href="#跨模块常量" class="headerlink" title="跨模块常量"></a>跨模块常量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//moudel1.js模块</div><div class="line">export const A=1;</div><div class="line">export const B=2;</div><div class="line">//test1.js模块</div><div class="line">import * as obj from &apos;./constants&apos;;</div><div class="line">console.log(obj.A)</div><div class="line">console.log(obj.B)</div><div class="line">//test2.js模块</div><div class="line">import &#123;A,B&#125; from &apos;./constants&apos;;</div><div class="line">console.log(A)</div><div class="line">console.log(B)</div></pre></td></tr></table></figure>
<h3 id="全局对象的属性"><a href="#全局对象的属性" class="headerlink" title="全局对象的属性"></a>全局对象的属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&apos;use strict&apos;;</div><div class="line">let b=0;</div><div class="line">console.log(this.b);//undefined</div><div class="line">console.log(window.b);//undefined</div></pre></td></tr></table></figure>
<h2 id="二-变量的解构赋值"><a href="#二-变量的解构赋值" class="headerlink" title="二.变量的解构赋值"></a>二.变量的解构赋值</h2><h3 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h3><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="#基本用法"></a>#基本用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//解构赋值</div><div class="line">let arr=[&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;,&quot;dd&quot;];</div><div class="line">let [a,b,c]=arr;</div><div class="line">console.log(a, b, c);</div><div class="line">//嵌套赋值</div><div class="line">let [x,y,[s],[[f]]]=[1,2,[3],[[4]]];</div><div class="line">console.log(x, y, s, f);</div><div class="line">//省略赋值</div><div class="line">let ary=[1,2,3,4,5,6];</div><div class="line">let [x,,,,y]=ary;</div><div class="line">console.log(x, y);</div><div class="line">//不定参数</div><div class="line">let [,,x,,...y]=[1,2,3,4,5,6,7,8,9,0];</div><div class="line">console.log(x, y);</div></pre></td></tr></table></figure>
<h3 id="默认值"><a href="#默认值" class="headerlink" title="#默认值"></a>#默认值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let [f2,f3=2]=[1];</div><div class="line">console.log(f2, f3);</div></pre></td></tr></table></figure>
<h3 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">//解构赋值</div><div class="line">let &#123;n,m:m1&#125;=&#123;n:&quot;nn&quot;,m:&apos;mm&apos;&#125;;</div><div class="line">console.log(n, m1);</div><div class="line">//嵌套</div><div class="line">let obj=&#123;s:&#123;n:&apos;1&apos;&#125;,n:[1,&quot;2&quot;,3,&quot;4&quot;],m:[[1]]&#125;;</div><div class="line">let &#123;m:[x1],s:&#123;n&#125;,n:[,...m2]&#125;=obj;</div><div class="line">console.log(x1, n, m2);</div><div class="line">//[1],&quot;1&quot;,[&quot;2&quot;,3,&quot;4&quot;]</div><div class="line">//默认值</div><div class="line">let &#123;m:n=4&#125;=&#123;&#125;;</div><div class="line">console.log(n);//4</div><div class="line">let &#123;a:cc=22&#125;=&#123;a:12&#125;;</div><div class="line">console.log(cc);//12</div><div class="line">//其他问题</div><div class="line">&apos;use strict&apos;;</div><div class="line">//赋的值不是一个对象是个其他数据类型的值,会默认将其他数据类型转为对象</div><div class="line">let &#123;x,y,__proto__&#125;=1;//&#123;__proto__:Number&#125;</div><div class="line">console.log(x, y,__proto__);</div><div class="line">console.log(Object(1));</div><div class="line">console.log(Object([1, 2, 3]));</div><div class="line">let &#123;length&#125;=[1,2,3];</div><div class="line">console.log(length);</div><div class="line"></div><div class="line">let a;</div><div class="line">//&#123;a&#125;=&#123;a:&quot;a&quot;&#125;;</div><div class="line">//JavaScrip引擎会将&#123;a&#125;理解成一个代码块</div><div class="line">//为了避免错误,不要将&#123;&#125;写在行首</div><div class="line">eval(&quot;(&#123;s:&apos;ss&apos;,d:&apos;d&apos;&#125;)&quot;);</div><div class="line">(&#123;a&#125;=&#123;a:&quot;a&quot;&#125;);</div><div class="line">console.log(a);</div><div class="line"></div><div class="line">(&#123;&#125;=[]);</div><div class="line">//null 和 undefined无法转为对象,所以对象结果赋值为一个null和undefined会报错</div><div class="line">//let &#123;p:yy&#125;=null;</div><div class="line">//let &#123;p:xx&#125;=undefined;</div></pre></td></tr></table></figure>
<h3 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//此时是将字符串转为类似数组的一个对象</div><div class="line">    let [x,y,z]=&apos;123&apos;;</div><div class="line">    console.log(x, y, z);</div><div class="line"></div><div class="line">    let &#123;length&#125;=&apos;12345&apos;;</div><div class="line">    console.log(length);</div><div class="line">    //console.log(Array(&quot;12345&quot;));</div></pre></td></tr></table></figure>
<h3 id="数值和布尔的结构赋值"><a href="#数值和布尔的结构赋值" class="headerlink" title="数值和布尔的结构赋值"></a>数值和布尔的结构赋值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//解构赋值时,如果等号右边是数值或者布尔值,则会先转为对象</div><div class="line">let &#123;toString:s&#125;=123;</div><div class="line">s===Number.prototype.toString ;//true</div><div class="line"></div><div class="line">let &#123;toString:t&#125;=true;</div><div class="line">t===Boolean.prototype.toString ;//true</div></pre></td></tr></table></figure>
<h3 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function move([x=10,y])&#123;</div><div class="line">	console.log(x,y)</div><div class="line">&#125;</div><div class="line">move([,3]);</div><div class="line">//注意:</div><div class="line">function get(&#123;x=0,y=0&#125;=&#123;&#125;)</div><div class="line">function get(&#123;x,y&#125;=&#123;x:0,y:0&#125;)</div></pre></td></tr></table></figure>
<h3 id="圆括号的问题"><a href="#圆括号的问题" class="headerlink" title="圆括号的问题"></a>圆括号的问题</h3><h3 id="不能使用括号的情况"><a href="#不能使用括号的情况" class="headerlink" title="#不能使用括号的情况"></a>#不能使用括号的情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//1.变量声明语句中,模式不能带有括号</div><div class="line">    let [(a)]=[1];</div><div class="line">    let &#123;x:(c)&#125;=&#123;&#125;;</div><div class="line">    let &#123;o:(&#123;p:p&#125;)&#125;=&#123;o:&#123;p:1&#125;&#125;</div><div class="line">//这三个都会报错</div><div class="line">//2.函数参数也属于变量声明,所以也不需要加括号</div><div class="line">function f([(z)])&#123;return z;&#125;//报错</div><div class="line">//3.不可以将整个模式或者嵌套模式中的一层放在括号中</div><div class="line">//全部报错</div><div class="line">(&#123;p:a&#125;)=&#123;p:2&#125;;</div><div class="line">([a])=[5];</div></pre></td></tr></table></figure>
<h3 id="可以使用括号的情况"><a href="#可以使用括号的情况" class="headerlink" title="#可以使用括号的情况"></a>#可以使用括号的情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">可以使用的只有只一种情况:赋值语句的非模式部分可以使用括号.</div><div class="line">[(b)]=[3];</div><div class="line">(&#123;p:(d)&#125;=&#123;&#125;);</div><div class="line">[(p.p)]=[3]</div></pre></td></tr></table></figure>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><h3 id="交换变量的值"><a href="#交换变量的值" class="headerlink" title="#交换变量的值"></a>#交换变量的值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[x,y]=[y,x]</div></pre></td></tr></table></figure>
<h3 id="从函数返回多个值"><a href="#从函数返回多个值" class="headerlink" title="#从函数返回多个值"></a>#从函数返回多个值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//返回一个数组</div><div class="line">function example()&#123;</div><div class="line">   return [1,2,3]</div><div class="line">&#125;</div><div class="line">let [a,b,c]=example();</div><div class="line">//返回一个对象</div><div class="line">function example()&#123;</div><div class="line">   return &#123;x:&quot;X&quot;,y:&quot;Y&quot;&#125;</div><div class="line">&#125;</div><div class="line">let [x,y]=example();</div></pre></td></tr></table></figure>
<h3 id="函数参数的定义"><a href="#函数参数的定义" class="headerlink" title="#函数参数的定义"></a>#函数参数的定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">function g([x,y,z])&#123;&#125;</div><div class="line">g([1,2,3])</div></pre></td></tr></table></figure>
<h3 id="提取JSON数据"><a href="#提取JSON数据" class="headerlink" title="#提取JSON数据"></a>#提取JSON数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//解构赋值对提取JSON对象中的数据尤其有用</div><div class="line">let jsonData=&#123;</div><div class="line">   id: 4,</div><div class="line">   status: &quot;ok&quot;,</div><div class="line">   data:[&#123;&quot;a&quot;:&quot;AA&quot;&#125;,&#123;&quot;b&quot;:&quot;BB&quot;&#125;]</div><div class="line">&#125;</div><div class="line">let &#123;id,status,data:result&#125;=jsonData;</div><div class="line">console.log(id,status,result)</div></pre></td></tr></table></figure>
<h3 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="#函数参数的默认值"></a>#函数参数的默认值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$.ajax=function(&#123;</div><div class="line">   type=&quot;get&quot;,</div><div class="line">   async=true,</div><div class="line">   cache=true,</div><div class="line">   global=true</div><div class="line">&#125;)&#123;</div><div class="line">   //函数体</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="遍历Map结构"><a href="#遍历Map结构" class="headerlink" title="#遍历Map结构"></a>#遍历Map结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//后面单独拿出来将</div><div class="line">//任何部署了Iterator接口的对象,都可以使用for....of循环遍历.Map结构原生支持Iterator接口,配合变量的解构赋值,获取键名和键值非常方便</div><div class="line">let map = new Map();</div><div class="line">map.set(&quot;a&quot;,&quot;A&quot;);</div><div class="line">map.set(&quot;b&quot;,&quot;B&quot;);</div><div class="line">for(let [key,value] of map)&#123;</div><div class="line">   console.log(key+&quot;:&quot;+value)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="输入模块的指定方法"><a href="#输入模块的指定方法" class="headerlink" title="#输入模块的指定方法"></a>#输入模块的指定方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//加载模块时</div><div class="line">const &#123;component&#125;=require(&apos;vue-router&apos;)</div></pre></td></tr></table></figure>
<h2 id="三-字符串的扩展"><a href="#三-字符串的扩展" class="headerlink" title="三.字符串的扩展"></a>三.字符串的扩展</h2><h3 id="includes-startsWidth-endsWidth"><a href="#includes-startsWidth-endsWidth" class="headerlink" title="includes(),startsWidth(),endsWidth()"></a>includes(),startsWidth(),endsWidth()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//includes() 判断字符串中有没有指定字符,有的话返回true,没有返回false</div><div class="line">//第二个参数:开始查找的索引 默认是0</div><div class="line">let str=&apos;asdfghjkl&apos;;</div><div class="line">console.log(str.includes(&apos;a&apos;,2));</div><div class="line">//startsWith()是不是以某个字符作为开头</div><div class="line">//endsWith()是不是以某个字符作为结尾</div><div class="line">//第二个参数:开始查找的索引 默认是0</div><div class="line">console.log(str.startsWith(&quot;d&quot;,2));</div><div class="line">console.log(str.endsWith(&quot;l&quot;));</div></pre></td></tr></table></figure>
<h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//repeat(n),将字符串重复n次返回,原字符串不变</div><div class="line">   console.log(str.repeat(2),str);</div><div class="line">//小数 向下取整</div><div class="line">   console.log(str.repeat(2.6));</div><div class="line"></div><div class="line">//负数/Infinity 报错的</div><div class="line">   console.log(str.repeat(-2));</div><div class="line">   console.log(str.repeat(Infinity));</div><div class="line">//0-&gt;-1 :先进行向下取整运算结果为0</div><div class="line">   console.log(str.repeat(-0.3));//&apos;&apos;</div><div class="line">//NaN =&gt; 0</div><div class="line">   console.log(str.repeat(NaN));//&apos;&apos;</div><div class="line">//字符串 将字符串变为数字</div><div class="line">    console.log(str.repeat(&quot;2&quot;));</div></pre></td></tr></table></figure>
<h3 id="padStart-padEnd"><a href="#padStart-padEnd" class="headerlink" title="padStart(),padEnd()"></a>padStart(),padEnd()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//ES7</div><div class="line">&quot;x&quot;.padStart(5,&quot;ab&quot;);//&quot;ababx&quot;</div><div class="line">&quot;x&quot;.padStart(4,&quot;ab&quot;);//&quot;abax&quot;</div><div class="line">&quot;x&quot;.padEnd(5,&quot;ab&quot;);//&quot;xabab&quot;</div><div class="line">&quot;x&quot;.padEnd(4,&quot;ab&quot;);//&quot;xaba&quot;</div><div class="line">&quot;x&quot;.padStart(4);//&quot;   x&quot;</div></pre></td></tr></table></figure>
<h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">&apos;use strict&apos;;</div><div class="line"> let str=&apos;I LOVE YOU&apos;;</div><div class="line"> document.body.innerHTML=&apos;&lt;h1&gt;&apos;+str+&apos;&lt;h1&gt;&apos;;</div><div class="line"> let str1=`&lt;h1&gt;$&#123;str&#125;&lt;/h1&gt;`;</div><div class="line"> document.body.innerHTML+=str1;</div><div class="line"></div><div class="line"> //保留换行和空格</div><div class="line"> console.log(&quot;hahahhah\nhhahah&quot;);</div><div class="line"> let s1=`hahah</div><div class="line">    ggagga</div><div class="line">    hhhh</div><div class="line">    `;</div><div class="line"> console.log(s1);</div><div class="line"></div><div class="line"> //\`</div><div class="line">    console.log(`sss\`1234`);</div><div class="line"></div><div class="line"> //&#123;可以实现运算&#125;</div><div class="line"> let x=1;</div><div class="line"> let y=2;</div><div class="line"> console.log(`$&#123;x&#125;+$&#123;y&#125;=$&#123;x + y&#125;`);</div><div class="line"></div><div class="line"> //调用函数</div><div class="line">    function fn(x) &#123;</div><div class="line">        return x</div><div class="line">    &#125;</div><div class="line">    let s2=&quot;XXX&quot;;</div><div class="line">    console.log(`函数fn输出的结果是$&#123;fn(s2)&#125;`);</div><div class="line"></div><div class="line">    let  s3=&apos;return&apos;+&apos;`Hello $&#123;wd&#125;`&apos;;</div><div class="line">    let fun=new Function(&apos;wd&apos;,s3);</div><div class="line">    console.log(fun(&quot;ZFPX&quot;));</div><div class="line">//Hello ZFPX</div></pre></td></tr></table></figure>
<h2 id="六-数组的扩展"><a href="#六-数组的扩展" class="headerlink" title="六.数组的扩展"></a>六.数组的扩展</h2><h3 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//Array.from()</div><div class="line">// 将一个数组和类数组转化为数组</div><div class="line">// 返回值是一个新数组</div><div class="line">// 原来数组不变</div><div class="line">let oldArr=[1,2,3,&quot;a&quot;,&quot;b&quot;];</div><div class="line">let newArr=Array.from(oldArr);</div><div class="line">console.log(newArr);</div></pre></td></tr></table></figure>
<h3 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//of 将一组数值转化为数组,类似Array方法</div><div class="line">console.log(Array.of(1,2,3))</div></pre></td></tr></table></figure>
<h3 id="数组实例的copyWithin"><a href="#数组实例的copyWithin" class="headerlink" title="数组实例的copyWithin()"></a>数组实例的copyWithin()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//Array.prototype.copyWithin(target,start,end)</div><div class="line">//target(必需)：从该位置开始替换数据。</div><div class="line">//start(可选)：从该位置开始读取数据，默认为 0 。如果为负值，表示倒数。</div><div class="line">//end(可选)：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。</div><div class="line">//这三个参数都应该是数值，如果不是，会自动转为数值。</div><div class="line">    let arr = [1, 2, 3, 4, 5];</div><div class="line">    arr.copyWithin(0, 1, 5);</div><div class="line">    console.log(arr);</div></pre></td></tr></table></figure>
<h3 id="数组实例的find-和findIndex"><a href="#数组实例的find-和findIndex" class="headerlink" title="数组实例的find()和findIndex()"></a>数组实例的find()和findIndex()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">let arr=[1,2,3,3,4,5];</div><div class="line">//返回值是找到的那一项,没有就是undefined</div><div class="line">let find=arr.find((item,index,arr)=&gt;&#123;</div><div class="line">    //item当前项,index:索引,arr:元素组</div><div class="line">    return item==0;</div><div class="line">&#125;);</div><div class="line">//返回值是找到的那一项的索引,没有就是-1</div><div class="line">let findIndex=arr.findIndex((item,index,arr)=&gt;&#123;</div><div class="line">    return item==0;</div><div class="line">&#125;);</div><div class="line">console.log(find, findIndex);</div></pre></td></tr></table></figure>
<h3 id="数组实例的fill"><a href="#数组实例的fill" class="headerlink" title="数组实例的fill()"></a>数组实例的fill()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//fill 联想canvas的fill方法填充的意思, 这里是填充数组,明显肯定会改变原数组</div><div class="line">//Array.prototype.fill(value,start,end)</div><div class="line">//value	必需。填充的值。</div><div class="line">//start	可选。开始填充位置(默认值为0)</div><div class="line">//end	可选。停止填充位置 (不包括该值,默认为 array.length)</div><div class="line">    let arr=[1,2,3,4,5];</div><div class="line">    arr.fill(&quot;a&quot;,0,1);</div><div class="line">    console.log(arr);</div></pre></td></tr></table></figure>
<h3 id="数组实例的entries-keys-和values"><a href="#数组实例的entries-keys-和values" class="headerlink" title="数组实例的entries(),keys()和values()"></a>数组实例的entries(),keys()和values()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">let arr=[1,2,3,4,5]</div><div class="line">for(let index of arr.keys())&#123;</div><div class="line">        console.log(item);</div><div class="line">    &#125;</div><div class="line">for(let item of arr.values())&#123;</div><div class="line">        console.log(item);</div><div class="line">    &#125;</div><div class="line">for(let [index,item] of arr.entries())&#123;</div><div class="line">        console.log(index,item);</div><div class="line">    &#125;</div><div class="line">let ary2=arr.entries();</div><div class="line">console.log(ary2.next().value);</div><div class="line">console.log(ary2.next().value);</div><div class="line">console.log(ary2.next().value);</div></pre></td></tr></table></figure>
<h3 id="数组实例的includes"><a href="#数组实例的includes" class="headerlink" title="数组实例的includes()"></a>数组实例的includes()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//includes 代替indexOf,返回值是true和false</div><div class="line">let arr=[NaN,&apos;a&apos;,0];</div><div class="line">console.log(arr.indexOf(NaN));</div><div class="line">console.log(arr.includes(NaN));</div><div class="line">//跟indexOf一样第二个参数可选</div></pre></td></tr></table></figure>
<h3 id="数组的空位"><a href="#数组的空位" class="headerlink" title="数组的空位"></a>数组的空位</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//空位不是undefined,可以使用in方法来检测一下</div><div class="line">//ES5 对空位的处理很不一致</div></pre></td></tr></table></figure>
<h2 id="七-函数的扩展"><a href="#七-函数的扩展" class="headerlink" title="七.函数的扩展"></a>七.函数的扩展</h2><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="#基本用法"></a>#基本用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function FF(x=0,y=0)&#123;</div><div class="line">   this.x=x;</div><div class="line">   this.y=y;</div><div class="line">&#125;</div><div class="line">let b=new FF()</div></pre></td></tr></table></figure>
<h3 id="与解构赋值默认值结合起来使用"><a href="#与解构赋值默认值结合起来使用" class="headerlink" title="#与解构赋值默认值结合起来使用"></a>#与解构赋值默认值结合起来使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function fn1(&#123;x=0,y=0&#125;=&#123;&#125;)&#123;</div><div class="line">   return [x,y]</div><div class="line">&#125;</div><div class="line">function fn2(&#123;x,y&#125;=&#123;x:0,y:0&#125;)&#123;</div><div class="line">   return [x,y]</div><div class="line">&#125;</div><div class="line">fn1();</div><div class="line">fn2();</div></pre></td></tr></table></figure>
<h3 id="参数默认值得位置"><a href="#参数默认值得位置" class="headerlink" title="#参数默认值得位置"></a>#参数默认值得位置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function fn(x,y=8,z)&#123;</div><div class="line">   return [x,y,z]</div><div class="line">&#125;</div><div class="line">fn(1,,3)//报错</div></pre></td></tr></table></figure>
<h3 id="函数的length属性"><a href="#函数的length属性" class="headerlink" title="#函数的length属性"></a>#函数的length属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">指定了参数默认值后,length属性返回的是没有默认值的参数长度</div></pre></td></tr></table></figure>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="#作用域"></a>#作用域</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//参数的作用域是当前函数</div><div class="line">let x=0;</div><div class="line">function fn (y=x,x)&#123;//报错</div><div class="line">   return [x,y]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">//...参数名</div></pre></td></tr></table></figure>
<h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><h3 id="含义"><a href="#含义" class="headerlink" title="#含义"></a>#含义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let print = function(a,b,c)&#123;</div><div class="line">    console.log(a,b,c);</div><div class="line">&#125;</div><div class="line">print([1,2,3]);</div><div class="line">print(...[1,2,3]);</div></pre></td></tr></table></figure>
<h3 id="替代数组的apply方法"><a href="#替代数组的apply方法" class="headerlink" title="#替代数组的apply方法"></a>#替代数组的apply方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let ary=[1,2,3]</div><div class="line">Math.apply(null,ary);</div><div class="line">Math(...ary);</div></pre></td></tr></table></figure>
<h3 id="扩展运算符的应用"><a href="#扩展运算符的应用" class="headerlink" title="#扩展运算符的应用"></a>#扩展运算符的应用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function fn ()&#123;</div><div class="line">   return [...arguments]</div><div class="line">&#125;</div><div class="line">[1,2].concat(1,...ary);</div></pre></td></tr></table></figure>
<h3 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let fn=function ()&#123;&#125;;</div><div class="line">console.log(fn.name);</div><div class="line">let obj=&#123;&#125;;</div><div class="line">let ff=fn.bind(obj);</div><div class="line">ff.name</div></pre></td></tr></table></figure>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><h3 id="基本用法-2"><a href="#基本用法-2" class="headerlink" title="#基本用法"></a>#基本用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let a=(x)=&gt;x*x;</div><div class="line">ary.forEach((item,index)=&gt;&#123;</div><div class="line">   ary[index]=item*10;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="使用注意点"><a href="#使用注意点" class="headerlink" title="#使用注意点"></a>#使用注意点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function fn()&#123;</div><div class="line">   this;</div><div class="line">   let x=()=&gt;&#123;</div><div class="line">      console.log(this)</div><div class="line">   &#125;</div><div class="line">   x();</div><div class="line">   return x;</div><div class="line">&#125;</div><div class="line">fn();</div><div class="line">let x=fn();</div><div class="line">x();</div><div class="line">fn.call(window)</div></pre></td></tr></table></figure>
<h3 id="嵌套的箭头函数"><a href="#嵌套的箭头函数" class="headerlink" title="#嵌套的箭头函数"></a>#嵌套的箭头函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let fun=(a)=&gt;&#123;</div><div class="line">       return(b)=&gt;&#123;</div><div class="line">           return(c)=&gt;&#123;</div><div class="line">               return a+b+c</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"> &#125;;</div><div class="line"> console.log(fun(10)(20)(30));</div><div class="line"> let fn=a=&gt;b=&gt;c=&gt;a+b+c;</div><div class="line"> console.log(fn(&quot;1&quot;)(&quot;2&quot;)(&quot;3&quot;));</div></pre></td></tr></table></figure>
<h2 id="八-对象的扩展"><a href="#八-对象的扩展" class="headerlink" title="八.对象的扩展"></a>八.对象的扩展</h2><h3 id="属性的简洁表示法"><a href="#属性的简洁表示法" class="headerlink" title="属性的简洁表示法"></a>属性的简洁表示法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">let a=&quot;A&quot;;</div><div class="line">let b=&quot;B&quot;;</div><div class="line">let obj3=&#123;a,b&#125;;</div><div class="line">//函数</div><div class="line">let objFn=&#123;</div><div class="line">     fn1:(a,b)=&gt;&#123;</div><div class="line">         console.log(a + b);</div><div class="line">         return a+b;</div><div class="line">     &#125;,</div><div class="line">     fn2(a,b)&#123;</div><div class="line">         console.log(a + b);</div><div class="line">         return a+b;</div><div class="line">     &#125;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure>
<h3 id="属性名的表达方式"><a href="#属性名的表达方式" class="headerlink" title="属性名的表达方式"></a>属性名的表达方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let a=&quot;AAA&quot;;</div><div class="line">let obj1=&#123;</div><div class="line">    [a]:&apos;a&apos;,</div><div class="line">    [a+&apos;fn&apos;]()&#123;</div><div class="line">        console.log(a + &apos;fn&apos;);</div><div class="line">    &#125;,</div><div class="line">    a</div><div class="line">&#125;;</div><div class="line">console.log(obj1);</div><div class="line">//&#123;AAA:&quot;a&quot;,AAAfn:ƒ (),a:&quot;AAA&quot;&#125;</div></pre></td></tr></table></figure>
<h3 id="方法的name属性"><a href="#方法的name属性" class="headerlink" title="方法的name属性"></a>方法的name属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let obj=&#123;</div><div class="line">   sum()&#123;</div><div class="line">      return eval([...argument].join(&quot;+&quot;));</div><div class="line">   &#125;,</div><div class="line">   add:(...all)=&gt;&#123;</div><div class="line">      return eval(all.join(&quot;+&quot;));</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">obj.add.name</div><div class="line">obj.sum.name</div></pre></td></tr></table></figure>
<h3 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">console.log(+0 === -0);//true</div><div class="line">console.log(Object.is(+0,-0));//false</div><div class="line">console.log(NaN === NaN);//false</div><div class="line">console.log(Object.is(NaN,NaN));//true</div></pre></td></tr></table></figure>
<h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//合并对象:Object.assign(obj1,obj2.....)</div><div class="line">//将obj2...合并到obj1上,将obj1返回</div><div class="line">//注意obj2...可以不是一个对象,属性名依次为&quot;0&quot;,&quot;1&quot;....</div><div class="line">Object.assign(&#123;&#125;,obj1)===obj1;</div><div class="line">Object.assign(obj1)===obj1;</div></pre></td></tr></table></figure>
<h3 id="属性的可枚举性"><a href="#属性的可枚举性" class="headerlink" title="属性的可枚举性"></a>属性的可枚举性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let obj = &#123; foo: 123 &#125;;</div><div class="line">Object.getOwnPropertyDescriptor(obj, &apos;foo&apos;)</div></pre></td></tr></table></figure>
<h3 id="属性的遍历"><a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">（1）for...in</div><div class="line">for...in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</div><div class="line">（2）Object.keys(obj)</div><div class="line">Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）。</div><div class="line">（3）Object.getOwnPropertyNames(obj)</div><div class="line">Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）。</div><div class="line">（4）Object.getOwnPropertySymbols(obj)</div><div class="line">Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性。</div><div class="line">（5）Reflect.ownKeys(obj)</div><div class="line">Reflect.ownKeys返回一个数组，包含对象自身的所有属性，不管属性名是 Symbol 或字符串，也不管是否可枚举。</div></pre></td></tr></table></figure>
<h3 id="proto属性-Object-setPrototypeOf-Object-getPrototypeOf"><a href="#proto属性-Object-setPrototypeOf-Object-getPrototypeOf" class="headerlink" title="proto属性,Object.setPrototypeOf(),Object.getPrototypeOf()"></a><strong>proto</strong>属性,Object.setPrototypeOf(),Object.getPrototypeOf()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//如果一个对象本身部署了__proto__属性，则该属性的值就是对象的原型。</div><div class="line">//Object.setPrototypeOf(object, prototype)</div><div class="line">//Object.getPrototypeOf(obj)</div><div class="line">//该方法与Object.setPrototypeOf方法配套，用于读取一个对象的原型对象。</div></pre></td></tr></table></figure>
<h2 id="十-Proxy和Reflect"><a href="#十-Proxy和Reflect" class="headerlink" title="十.Proxy和Reflect"></a>十.Proxy和Reflect</h2><h3 id="Proxy概述"><a href="#Proxy概述" class="headerlink" title="Proxy概述"></a>Proxy概述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let proxy=new Proxy(&#123;a:&quot;a&quot;,b:&quot;b&quot;&#125;,&#123;&#125;);</div><div class="line">proxy.a;</div><div class="line">proxy.b=&quot;bb&quot;;</div></pre></td></tr></table></figure>
<h3 id="Proxy实例的方法"><a href="#Proxy实例的方法" class="headerlink" title="Proxy实例的方法"></a>Proxy实例的方法</h3><h3 id="get"><a href="#get" class="headerlink" title="#get()"></a>#get()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">get方法用于拦截某个属性的读取操作。上文已经有一个例子，下面是另一个拦截读取操作的例子。</div></pre></td></tr></table></figure>
<h3 id="set"><a href="#set" class="headerlink" title="#set()"></a>#set()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set方法用来拦截某个属性的赋值操作。</div></pre></td></tr></table></figure>
<h3 id="apply"><a href="#apply" class="headerlink" title="#apply()"></a>#apply()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">apply方法拦截函数的调用、call和apply操作。</div><div class="line">apply方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组。</div></pre></td></tr></table></figure>
<h3 id="has"><a href="#has" class="headerlink" title="#has()"></a>#has()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">has方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是in运算符。</div></pre></td></tr></table></figure>
<h3 id="construct"><a href="#construct" class="headerlink" title="#construct()"></a>#construct()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">construct方法用于拦截new命令，下面是拦截对象的写法</div><div class="line">参数:</div><div class="line">target: 目标对象</div><div class="line">args：构建函数的参数对象</div></pre></td></tr></table></figure>
<h3 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="#deleteProperty()"></a>#deleteProperty()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">deleteProperty方法用于拦截delete操作，如果这个方法抛出错误或者返回false，当前属性就无法被delete命令删除。</div></pre></td></tr></table></figure>
<h3 id="defineProperty"><a href="#defineProperty" class="headerlink" title="#defineProperty()"></a>#defineProperty()</h3><h3 id="enunerate"><a href="#enunerate" class="headerlink" title="#enunerate()"></a>#enunerate()</h3><h3 id="getOwnPropertyDsecriptor"><a href="#getOwnPropertyDsecriptor" class="headerlink" title="#getOwnPropertyDsecriptor()"></a>#getOwnPropertyDsecriptor()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">getOwnPropertyDescriptor方法拦截Object.getOwnPropertyDescriptor()，返回一个属性描述对象或者undefined。</div></pre></td></tr></table></figure>
<h3 id="getPrototypeOf"><a href="#getPrototypeOf" class="headerlink" title="#getPrototypeOf()"></a>#getPrototypeOf()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">getPrototypeOf方法主要用来拦截获取对象原型。具体来说，拦截下面这些操作。</div><div class="line"></div><div class="line">Object.prototype.__proto__</div><div class="line">Object.prototype.isPrototypeOf()</div><div class="line">Object.getPrototypeOf()</div><div class="line">Reflect.getPrototypeOf()</div><div class="line">instanceof</div></pre></td></tr></table></figure>
<h3 id="isExtensible"><a href="#isExtensible" class="headerlink" title="#isExtensible()"></a>#isExtensible()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">isExtensible方法拦截Object.isExtensible操作。</div><div class="line">上面代码设置了isExtensible方法，在调用Object.isExtensible时会输出called。</div><div class="line">注意，该方法只能返回布尔值，否则返回值会被自动转为布尔值。</div></pre></td></tr></table></figure>
<h3 id="ownKeys"><a href="#ownKeys" class="headerlink" title="#ownKeys()"></a>#ownKeys()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ownKeys方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。</div><div class="line">Object.getOwnPropertyNames()</div><div class="line">Object.getOwnPropertySymbols()</div><div class="line">Object.keys()</div></pre></td></tr></table></figure>
<h3 id="preventExtensions"><a href="#preventExtensions" class="headerlink" title="#preventExtensions()"></a>#preventExtensions()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">preventExtensions方法拦截Object.preventExtensions()。该方法必须返回一个布尔值，否则会被自动转为布尔值。</div><div class="line"></div><div class="line">这个方法有一个限制，只有目标对象不可扩展时（即Object.isExtensible(proxy)为false），proxy.preventExtensions才能返回true，否则会报错。</div></pre></td></tr></table></figure>
<h3 id="setPrototypeOf"><a href="#setPrototypeOf" class="headerlink" title="#setPrototypeOf"></a>#setPrototypeOf</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">setPrototypeOf() </div><div class="line">setPrototypeOf方法主要用来拦截Object.setPrototypeOf方法。</div></pre></td></tr></table></figure>
<h3 id="Proxy-revocable"><a href="#Proxy-revocable" class="headerlink" title="Proxy.revocable()"></a>Proxy.revocable()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Proxy.revocable()</div><div class="line">Proxy.revocable方法返回一个可取消的 Proxy 实例。</div><div class="line">let target = &#123;&#125;;</div><div class="line">let handler = &#123;&#125;;</div><div class="line"></div><div class="line">let &#123;proxy, revoke&#125; = Proxy.revocable(target, handler);</div><div class="line"></div><div class="line">proxy.foo = 123;</div><div class="line">proxy.foo // 123</div><div class="line"></div><div class="line">revoke();</div><div class="line">proxy.foo // TypeError: Revoked</div><div class="line">Proxy.revocable方法返回一个对象，该对象的proxy属性是Proxy实例，revoke属性是一个函数，可以取消Proxy实例。上面代码中，当执行revoke函数之后，再访问Proxy实例，就会抛出一个错误。</div></pre></td></tr></table></figure>
<h3 id="Reflect概述"><a href="#Reflect概述" class="headerlink" title="Reflect概述"></a>Reflect概述</h3><h3 id="Reflect对象的方法"><a href="#Reflect对象的方法" class="headerlink" title="Reflect对象的方法"></a>Reflect对象的方法</h3><h2 id="十一-Set和Map数据结构"><a href="#十一-Set和Map数据结构" class="headerlink" title="十一.Set和Map数据结构"></a>十一.Set和Map数据结构</h2><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h3 id="基本用法-3"><a href="#基本用法-3" class="headerlink" title="#基本用法"></a>#基本用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//new Set(数组),会去除重复项,得到是个类数组</div><div class="line">let set1=new Set([&#123;&#125;,&#123;&#125;,&apos;a&apos;,&quot;a&quot;,NaN,NaN,null,null,undefined,undefined,0,-0,+0,]);</div></pre></td></tr></table></figure>
<h3 id="Set实例的属性和方法"><a href="#Set实例的属性和方法" class="headerlink" title="#Set实例的属性和方法"></a>#Set实例的属性和方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//基本操作,Set原型上的共有方法</div><div class="line">//add 添加  返回值:增加后的set</div><div class="line">//delete 删除  返回值:是否删除成功</div><div class="line">//has 查找 返回值:是否存在当前项</div><div class="line">//clear 清空 无返回值</div></pre></td></tr></table></figure>
<h3 id="遍历操作"><a href="#遍历操作" class="headerlink" title="#遍历操作"></a>#遍历操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//遍历操作</div><div class="line">    //keys</div><div class="line">    //values</div><div class="line">    //entries</div><div class="line">    //forEach</div></pre></td></tr></table></figure>
<h3 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//只有一下三种方法</div><div class="line">   //add</div><div class="line">   //delete</div><div class="line">   //has</div><div class="line">   let obj1=&#123;a:&quot;a&quot;&#125;;</div><div class="line">   let obj2=&#123;b:&quot;b&quot;&#125;;</div><div class="line">   let weak=new WeakSet([obj1,obj2]);</div><div class="line">   console.log(weak);</div></pre></td></tr></table></figure>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h3 id="Map结构的目的和基本用法"><a href="#Map结构的目的和基本用法" class="headerlink" title="#Map结构的目的和基本用法"></a>#Map结构的目的和基本用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">//我们说了对象的属性名必须是字符串,所以会默认讲其转为字符串,当做键值</div><div class="line">    //为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</div><div class="line">    //Map属于类数组</div><div class="line"></div><div class="line">    //1.第一种方式</div><div class="line">    let map = new Map();</div><div class="line">    map.set(ary, &quot;哈哈&quot;);</div><div class="line">    map.set(o, &quot;嘿嘿&quot;);</div><div class="line">    console.log(map);</div><div class="line"></div><div class="line"></div><div class="line">    //2.第二种方式</div><div class="line">    let map1 = new Map([[ary, &quot;哈哈&quot;], [o, &quot;嘿嘿&quot;]]);</div><div class="line">    console.log(map1);</div><div class="line"></div><div class="line">    //3.get方式获取</div><div class="line">    console.log(map.get(o));</div><div class="line">    console.log(map1.get(ary));</div><div class="line"></div><div class="line">    //4.Map 转数组</div><div class="line">    let arr=[...map];</div><div class="line">    let arr1=[...map1];</div><div class="line">    console.log(arr, arr1);</div><div class="line"></div><div class="line">    //5. 数组转为Map</div><div class="line">    let ary1=[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;];</div><div class="line">    let mapVal=ary1.map((item,index,arr)=&gt;[index,item]);</div><div class="line">    let arrToMap=new Map(mapVal);</div><div class="line">    console.log(arrToMap)</div></pre></td></tr></table></figure>
<h3 id="实例的属性和操作方法"><a href="#实例的属性和操作方法" class="headerlink" title="#实例的属性和操作方法"></a>#实例的属性和操作方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//属性和方法</div><div class="line">    // size:返回 Map 结构的成员总数</div><div class="line">    // set(key, value):设置键名key对应的键值为value，然后返回整个 Map 结构(因此可以采用链式写法)。如果key已经有值，则键值会被更新，否则就新生成该键。</div><div class="line">    // get(key):读取key对应的键值，如果找不到key，返回undefined</div><div class="line">    // has:返回一个布尔值，表示某个键是否在当前 Map 对象之中。</div><div class="line">    // delete:删除某个键，返回true。如果删除失败，返回false。</div><div class="line">    // clear:清除所有成员，没有返回值。</div></pre></td></tr></table></figure>
<h3 id="遍历方法"><a href="#遍历方法" class="headerlink" title="#遍历方法"></a>#遍历方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// keys()：返回键名的遍历器。</div><div class="line">// values()：返回键值的遍历器。 </div><div class="line">// entries()：返回所有成员的遍历器。</div><div class="line">// forEach()：遍历 Map 的所有成员</div></pre></td></tr></table></figure>
<h3 id="以其他数据结构的相互转换"><a href="#以其他数据结构的相互转换" class="headerlink" title="#以其他数据结构的相互转换"></a>#以其他数据结构的相互转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">//（1）Map 转为数组</div><div class="line">    //前面已经提过，Map 转为数组最方便的方法，就是使用扩展运算符（...）。</div><div class="line">    const myMap = new Map()</div><div class="line">        .set(true, 7)</div><div class="line">        .set(&#123;foo: 3&#125;, [&apos;abc&apos;]);</div><div class="line">    console.log([...myMap]);</div><div class="line"></div><div class="line">    //（2）数组 转为 Map</div><div class="line">    //将数组传入 Map 构造函数，就可以转为 Map。</div><div class="line">    new Map([</div><div class="line">        [true, 7],</div><div class="line">        [&#123;foo: 3&#125;, [&apos;abc&apos;]]</div><div class="line">    ]);</div><div class="line">    </div><div class="line">    //（3）Map 转为对象</div><div class="line">    //如果所有 Map 的键都是字符串，它可以转为对象。</div><div class="line">    function strMapToObj(strMap) &#123;</div><div class="line">        let obj = Object.create(null);</div><div class="line">        for (let [k,v] of strMap) &#123;</div><div class="line">            obj[k] = v;</div><div class="line">        &#125;</div><div class="line">        return obj;</div><div class="line">    &#125;</div><div class="line">    const myMap = new Map()</div><div class="line">        .set(&apos;yes&apos;, true)</div><div class="line">        .set(&apos;no&apos;, false);</div><div class="line">    strMapToObj(myMap);</div><div class="line"></div><div class="line">    //（4）对象转为 Map</div><div class="line">    function objToStrMap(obj) &#123;</div><div class="line">        let strMap = new Map();</div><div class="line">        for (let k of Object.keys(obj)) &#123;</div><div class="line">            strMap.set(k, obj[k]);</div><div class="line">        &#125;</div><div class="line">        return strMap;</div><div class="line">    &#125;</div><div class="line">    objToStrMap(&#123;yes: true, no: false&#125;);</div><div class="line"></div><div class="line">    //（5）Map 转为 JSON</div><div class="line">    //Map 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。</div><div class="line">    function strMapToJson(strMap) &#123;</div><div class="line">        return JSON.stringify(strMapToObj(strMap));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    let myMap = new Map().set(&apos;yes&apos;, true).set(&apos;no&apos;, false);</div><div class="line">    strMapToJson(myMap);</div><div class="line"></div><div class="line">    //另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。</div><div class="line">    function mapToArrayJson(map) &#123;</div><div class="line">        return JSON.stringify([...map]);</div><div class="line">    &#125;</div><div class="line">    let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, [&apos;abc&apos;]);</div><div class="line">    mapToArrayJson(myMap);</div><div class="line"></div><div class="line">    //（6）JSON 转为 Map</div><div class="line">    //JSON 转为 Map，正常情况下，所有键名都是字符串。</div><div class="line">    function jsonToStrMap(jsonStr) &#123;</div><div class="line">        return objToStrMap(JSON.parse(jsonStr));</div><div class="line">    &#125;</div><div class="line">    jsonToStrMap(&apos;&#123;&quot;yes&quot;: true, &quot;no&quot;: false&#125;&apos;);</div><div class="line"></div><div class="line">    //但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为Map。这往往是数组转为 JSON 的逆操作。</div><div class="line">    function jsonToMap(jsonStr) &#123;</div><div class="line">        return new Map(JSON.parse(jsonStr));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    jsonToMap(&apos;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&apos;);</div></pre></td></tr></table></figure>
<h3 id="WeakMap"><a href="#WeakMap" class="headerlink" title="WeakMap"></a>WeakMap</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//WeakMap结构与Map结构类似，也是用于生成键值对的集合。</div><div class="line">    //WeakMap与Map的区别有两点。</div><div class="line">    //1)WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。</div><div class="line">    //2)WeakMap的键名所指向的对象，不计入垃圾回收机制。</div><div class="line">    //WeakMap 就是为了解决这个内存泄漏而诞生的，它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。</div><div class="line"></div><div class="line">   // 基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用WeakMap结构。当该 DOM 元素被清除，其所对应的WeakMap记录就会自动被移除。</div><div class="line"></div><div class="line">    //只有四个方法可用：get()、set()、has()、delete()。</div></pre></td></tr></table></figure>
<h2 id="十二-Iterator和for…of循环"><a href="#十二-Iterator和for…of循环" class="headerlink" title="十二.Iterator和for…of循环"></a>十二.Iterator和for…of循环</h2><h3 id="Iterator的概念"><a href="#Iterator的概念" class="headerlink" title="Iterator的概念"></a>Iterator的概念</h3><h3 id="数据结构的默认Iterator接口"><a href="#数据结构的默认Iterator接口" class="headerlink" title="数据结构的默认Iterator接口"></a>数据结构的默认Iterator接口</h3><h3 id="调用iterator接口场合"><a href="#调用iterator接口场合" class="headerlink" title="调用iterator接口场合"></a>调用iterator接口场合</h3><h3 id="字符串的iterator接口"><a href="#字符串的iterator接口" class="headerlink" title="字符串的iterator接口"></a>字符串的iterator接口</h3><h3 id="Iterator接口和Generator函数"><a href="#Iterator接口和Generator函数" class="headerlink" title="Iterator接口和Generator函数"></a>Iterator接口和Generator函数</h3><h3 id="遍历器对象的return-throw函数"><a href="#遍历器对象的return-throw函数" class="headerlink" title="遍历器对象的return(),throw函数"></a>遍历器对象的return(),throw函数</h3><h3 id="for-…-of循环"><a href="#for-…-of循环" class="headerlink" title="for …. of循环"></a>for …. of循环</h3><h3 id="数组"><a href="#数组" class="headerlink" title="#数组"></a>#数组</h3><h3 id="Set和Map结构"><a href="#Set和Map结构" class="headerlink" title="#Set和Map结构"></a>#Set和Map结构</h3><h3 id="计算生成的数据结构"><a href="#计算生成的数据结构" class="headerlink" title="#计算生成的数据结构"></a>#计算生成的数据结构</h3><h3 id="类似数组的对象"><a href="#类似数组的对象" class="headerlink" title="#类似数组的对象"></a>#类似数组的对象</h3><h3 id="对象"><a href="#对象" class="headerlink" title="#对象"></a>#对象</h3><h3 id="与其他遍历语法的比较"><a href="#与其他遍历语法的比较" class="headerlink" title="#与其他遍历语法的比较"></a>#与其他遍历语法的比较</h3><h2 id="十三-Generactor函数"><a href="#十三-Generactor函数" class="headerlink" title="十三.Generactor函数"></a>十三.Generactor函数</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="#基本概念"></a>#基本概念</h3><h3 id="yield语句"><a href="#yield语句" class="headerlink" title="#yield语句"></a>#yield语句</h3><h3 id="与Iterator接口的关系"><a href="#与Iterator接口的关系" class="headerlink" title="#与Iterator接口的关系"></a>#与Iterator接口的关系</h3><h3 id="next-方法的参数"><a href="#next-方法的参数" class="headerlink" title="next 方法的参数"></a>next 方法的参数</h3><h3 id="for…of-循环"><a href="#for…of-循环" class="headerlink" title="for…of 循环"></a>for…of 循环</h3><h3 id="Generator-prototype-throw"><a href="#Generator-prototype-throw" class="headerlink" title="Generator.prototype.throw()"></a>Generator.prototype.throw()</h3><h3 id="Generator-prototype-return"><a href="#Generator-prototype-return" class="headerlink" title="Generator.prototype.return()"></a>Generator.prototype.return()</h3><h3 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield* 表达式"></a>yield* 表达式</h3><h3 id="作为对象属性的Generator函数"><a href="#作为对象属性的Generator函数" class="headerlink" title="作为对象属性的Generator函数"></a>作为对象属性的Generator函数</h3><h3 id="Generator-函数的this"><a href="#Generator-函数的this" class="headerlink" title="Generator 函数的this"></a>Generator 函数的this</h3><h3 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h3><h3 id="Generator与状态机"><a href="#Generator与状态机" class="headerlink" title="#Generator与状态机"></a>#Generator与状态机</h3><h3 id="Generator与协程"><a href="#Generator与协程" class="headerlink" title="#Generator与协程"></a>#Generator与协程</h3><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h2 id="十四-Promise对象"><a href="#十四-Promise对象" class="headerlink" title="十四.Promise对象"></a>十四.Promise对象</h2><h3 id="Promise-的含义"><a href="#Promise-的含义" class="headerlink" title="Promise 的含义"></a>Promise 的含义</h3><h3 id="基本用法-4"><a href="#基本用法-4" class="headerlink" title="基本用法"></a>基本用法</h3><h3 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h3><h3 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h3><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h3><h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h3><h3 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h3><h3 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h3><h3 id="两个有用的附加方法"><a href="#两个有用的附加方法" class="headerlink" title="两个有用的附加方法"></a>两个有用的附加方法</h3><h3 id="done"><a href="#done" class="headerlink" title="#done()"></a>#done()</h3><h3 id="dinally"><a href="#dinally" class="headerlink" title="#dinally()"></a>#dinally()</h3><h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><h3 id="加载图片"><a href="#加载图片" class="headerlink" title="#加载图片"></a>#加载图片</h3><h3 id="Generator函数与Promise结合"><a href="#Generator函数与Promise结合" class="headerlink" title="#Generator函数与Promise结合"></a>#Generator函数与Promise结合</h3><h3 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h3>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2017 王诗杰
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/smackgg/hexo-theme-smackdown" target="_blank">Smackdown</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="/js/main.js"></script>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>